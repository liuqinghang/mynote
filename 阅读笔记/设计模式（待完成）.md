# 二十三种设计模式



## 五种创建型模式



### 一、工厂方法（Factory Method）

#### 1、普通工厂

> 建立工厂类,实现对同一接口的类实例的创建

一个接口,有两个/多个实现类,工厂类中含有具体**某个**方法(返回类型为接口)返回对应的实现类

#### 2、多个工厂方法模式

> 是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串
出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。

一个接口,有两个/多个实现类,工厂类中含有具体**多个**方法返回分别对应的实现类

#### 3、静态工厂

> 将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调
> 用即可

即在测试类中不需要在创建工厂类,直接调用对应方法即可



------

### 二、抽象工厂（Abstract Factory）

> 为了方便拓展,提出抽象工厂: 多个工厂类,工厂类实现工厂接口,每个工厂类对应不同的实现类

优势:想增加一个功能,实现一个实现类,一个工厂类即可 (继承相应的接口)





------

### 三、单例模式（Singleton）

```java
public class SingletonTest {
    
    private static SingletonTest instance = null;

    private SingletonTest() {}

    private static synchronized void syncInit() {
        if (instance == null) {
        	instance = new SingletonTest();
        }
    }

    public static SingletonTest getInstance() {
        if (instance == null) {
        	syncInit();
        }
    	return instance;
    }
}
```





------

### 四、建造者模式（Builder）

> 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复
> 合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的
> Test结合起来得到的

与工厂模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建多个产品

---

### 五、原型模式（ProtoType）

> 从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。在java中复制对象通过clone（）实现

复制对象有两种方式，深复制和浅复制

- 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深
  复制进行了完全彻底的复制，而浅复制不彻底
- 将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指
  向的。内部成员是引用值时将被共用

```java
/* 浅复制 */
public Object clone() throws CloneNotSupportedException {
	Prototype proto = (Prototype) super.clone();
	return proto;
}

/* 深复制 */
public Object deepClone() throws IOException, ClassNotFoundException {

     /* 写入当前对象的二进制流 */
    ByteArrayOutputStream bos = new ByteArrayOutputStream();
    ObjectOutputStream oos = new ObjectOutputStream(bos);
    oos.writeObject(this);

    /* 读出二进制流产生的新对象 */
    ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
    ObjectInputStream ois = new ObjectInputStream(bis);
    return ois.readObject();
}
```





## 七种结构型模式



### 六、适配器模式（Adapter）

- 类的适配器模式
  - 核心思想：例 有一个Source类，拥有一个方法，待适配，目标接口为Targetable，通过Adapter
    类，将Source的功能扩展到Targetable里
  - Source类中含有方法method1() ,目标接口中也有一个method1()
  - **Adapter** 类继承Source并实现Targetable，这样Targetable接口的实现类就自动有了Source类的method1()方法(且无需手动覆盖重写)
- 对象的适配器模式（Wraper）
  - 核心思想：与以上一致
  - **Warper**类继承Targetable并将目标Source类持为成员，并有对应带参的构造方法，此时重写的method1()方法返回值为 成员Source类的method1() 方法的返回值
- 接口的适配器模式
  - 核心思想：接口庞大时无必要实现所有的方法，借助抽象类达到只实现部分接口的需求
  - 目标接口拥有多个方法，抽象类继承该接口并实现所有方法，实现类继承该抽象类选择性实现部分实际需要的方法





---



### 七、装饰模式（Decorator）

> 顾名思义，就是给某个对象添加新的功能/方法，并要求动态实现的 
>
> 要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例

具体的实现方式：Decorator类继承同样的接口并将目标类置为成员，并有对应带参的构造方法，然后在其中实现需要增加的方法。使用时，将Decorator类的引用赋给目标实现类



应用场景：
1、需要扩展一个类的功能。
2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）
缺点：产生过多相似的对象，不易排错！、



---

### 八、代理模式（Proxy）

> 代理模式就是多一个代理类出来，替原对象进行一些操作



具体的实现方式：Proxy类继承同样的接口并将目标类置为成员，并有对应带参的构造方法，重写目标类中需要代理的方法

应用场景：
如果已有的方法在使用的时候需要对原有的方法进行**改进**，此时有两种办法：
1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。
使用代理模式，可以将功能划分的更加清晰，有助于后期维护！



---

### 九、外观模式（Facade）

> 外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文
> 件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有
> 涉及到接口



具体实现方法： 例如disk ，cup，memory 等多个实现类有多个方法， 且其中存在多种关系，将对应的关系放在类似配置文件的类中，例如将 电脑启动时对应disk，cpu，memory 类的start()方法均被调用，则将这些方法集成到computer类的star() 方法中，此时computer类就是一个Facade类

此时就将关系均放在Computer类中，达到了解耦的目的



---

### 十、桥接模式（Bridge）

> 桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现
> 化解耦，使得二者可以独立变化



具体实现方法：目标接口具有多个实现类，抽象类Bridge将目标接口置为成员（getter 和 setter），添加与目标method1()方法同名的方法返回值为接口成员的对应method1()方法值。 MyBridge实现Bridge ，重写method1() 将返回值设为getBridge().method1(); 达到的效果就是对于加载了不同的实现类的MyBridge调用相同的方法能实现不同的方法



---

### 十一、组合模式（Composite）

> 组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便

具体实现方法:例如二叉树,每个子节点可看作一个单独的类,根可以看作多个数组合而成

使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。



---

### 十二、享元模式（Flyweight）

> 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。

FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。

适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClass Name、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量

---



## 十一种行为型模式

十一种模式的关系

![image-20210312141745194](C:\Users\路瞳\AppData\Roaming\Typora\typora-user-images\image-20210312141745194.png)



---

### 十三、策略模式（strategy）

> 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数

选择目标算法后仅调用该接口的相应方法

策略模式，即指定义一组算法，将每个算法都封装起来，并且使它们之间可以互换



---

### 十四、模板方法模式（Template Method）

>  模板方法模式展示了面向对象编程中诸多经典重用形式中的一种。其中通用算法被放置在基类中，并且通过继承在不同的具体上下文中实现该通用算法。

模板方法的使用场景：

 ● 多个子类有公有的方法,并且逻辑基本相同时；

 ● 重要、复杂的算法,可以把核心算法设计为模板方法，周边的相关细节功能则由各个子类实现；

 ● 重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。



---

### 十五、观察者模式（Observer）

[菜鸟教程]: https://www.runoob.com/design-pattern/observer-pattern.html



---

### 十六、迭代子模式（Iterator）

相当于自定义迭代器,顺序访问聚合对象的成员,

**优点：** 1、它支持以不同的方式遍历一个聚合对象。 2、迭代器简化了聚合类。 3、在同一个聚合上可以有多个遍历。 4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。

**缺点：**由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。

**使用场景：** 1、访问一个聚合对象的内容而无须暴露它的内部表示。 2、需要为聚合对象提供多种遍历方式。 3、为遍历不同的聚合结构提供一个统一的接口



---

### 十七、责任链模式（Chain of Responsibility）

> 有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。



---

### 十八、命令模式（Command）

### 十九、备忘录模式（Memento）

### 二十、状态模式（State）

### 二十一、访问者模式（Visitor）

### 二十二、中介者模式（Mediator）

### 二十三、解释器模式（Interpreter）