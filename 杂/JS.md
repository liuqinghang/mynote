# JS

### let 关键字

使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。

```javascript
 {
	console.log( bar ); // ReferenceError!
 	let bar = 2;
}
```

let 定义所在的块在运行后被垃圾回收
for循环中用let定义变量

申明在编译阶段，赋值等操作在运行阶段
函数声明和变量声明都会被提升，先函数 后变量
重复的var会被覆盖，
延迟函数的回调会在循环结束时才执行

简单来说，箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所 有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值
this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。
对象属性引用链中只有最顶层或者说最后一层会影响调用位置 最后一层

call方法  把对象作为参数的调用的方法

如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。 

1. 由 new 调用？绑定到新创建的对象。 
2. 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。
3. 由上下文对象调用？绑定到那个上下文对象。
4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象