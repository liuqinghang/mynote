# HTML

### 一 块级元素与内联元素

> 内联元素 定义：只占据它对应标签的边框所包含的空间。只能容纳文本或者其他内联元素元素。

> 块级元素 定义：占据其父元素（容器）的整个空间，因此创建了一个“块”。通常浏览器会在块级元素前后另起一行。能容纳其他块元素或者内联元素。

| 块元素                             | 内联元素                     |
| ---------------------------------- | ---------------------------- |
| 总在新行开始                       | 和其他元素在同一行           |
| 能容纳其他块元素或者内联元素       | 只能容纳文本或其他内联元素   |
| 高度，行高以及顶和底边距都可以控制 | 高，行高及顶和底边距不可改变 |

块元素和内联元素切换

```
1.display  
块元素默认display:block;行内非替换元素(a,span)默认为display：inline;行内替换元素(input)默认为display:inline-block;  
display:none;不显示该元素，也不会保留该元素原先占有的文档流位置。  
display:block;转换为块级元素。  
display:inline;转换为行内元素。  
display:inline-block;转换为行内块级元素。  
2.float  
当把行内元素设置完float:left/right后，该行内元素的display属性会被赋予block值，且拥有浮动特性。行内元素去除了之间的莫名空白。  
3.position  
当为行内元素进行定位时，position:absolute与position:fixed.都会使得原先的行内元素变为块级元素。
```



# ThymeLeaf

# JS

### let 关键字

使用 let 进行的声明不会在块作用域中进行提升。声明的代码被运行之前，声明并不“存在”。

```javascript
 {
	console.log( bar ); // ReferenceError!
 	let bar = 2;
}
```

let 定义所在的块在运行后被垃圾回收
for循环中用let定义变量

申明在编译阶段，赋值等操作在运行阶段
函数声明和变量声明都会被提升，先函数 后变量
重复的var会被覆盖，
延迟函数的回调会在循环结束时才执行

简单来说，箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所 有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值
this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。
对象属性引用链中只有最顶层或者说最后一层会影响调用位置 最后一层

call方法  把对象作为参数的调用的方法

如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后 就可以顺序应用下面这四条规则来判断 this 的绑定对象。 

1. 由 new 调用？绑定到新创建的对象。 
2. 由 call 或者 apply（或者 bind）调用？绑定到指定的对象。
3. 由上下文对象调用？绑定到那个上下文对象。
4. 默认：在严格模式下绑定到 undefined，否则绑定到全局对象

#### 变量与作用域

JavaScript 是使用垃圾回收的语言 

两种主要的标记策略：标记清理和引用计数